{
  "title": "Verifying Signatures",
  "content": "Source: https://docs.exa.ai/websets/api/webhooks/verifying-signatures\n\nLearn how to securely verify webhook signatures to ensure requests are from Exa\n\nWhen you receive a webhook from Exa, you should verify that it came from us to ensure the integrity and authenticity of the data. Exa signs all webhook payloads with a secret key that's unique to your webhook endpoint.\n\n## How Webhook Signatures Work\n\nExa uses HMAC SHA256 to sign webhook payloads. The signature is included in the `Exa-Signature` header, which contains:\n\n* A timestamp (`t=`) indicating when the webhook was sent\n* One or more signatures (`v1=`) computed using the timestamp and payload\n\nThe signature format looks like this:\n\n## Verification Process\n\nTo verify a webhook signature:\n\n1. Extract the timestamp and signatures from the `Exa-Signature` header\n2. Create the signed payload by concatenating the timestamp, a period, and the raw request body\n3. Compute the expected signature using HMAC SHA256 with your webhook secret\n4. Compare your computed signature with the provided signatures\n\n<Tabs>\n  <Tab title=\"Python\">\n    \n  </Tab>\n\n<Tab title=\"JavaScript/Node.js\">\n    \n  </Tab>\n\n<Tab title=\"Java\">\n    \n  </Tab>\n</Tabs>\n\n## Security Best Practices\n\nFollowing these practices will help ensure your webhook implementation is secure and robust:\n\n* **Always Verify Signatures** - Never process webhook data without first verifying the signature. This prevents attackers from sending fake webhooks to your endpoint.\n\n* **Use Timing-Safe Comparison** - When comparing signatures, use functions like `hmac.compare_digest()` in Python or `crypto.timingSafeEqual()` in Node.js to prevent timing attacks.\n\n* **Check Timestamp Freshness** - Consider rejecting webhooks with timestamps that are too old (e.g., older than 5 minutes) to prevent replay attacks.\n\n* **Store Secrets Securely** - Store your webhook secrets in environment variables or a secure secret management system. Never hardcode them in your application. **Important**: The webhook secret is only returned when you [create a webhook](https://docs.exa.ai/websets/api/webhooks/create-a-webhook) - make sure to save it securely as it cannot be retrieved later.\n\n* **Use HTTPS** - Always use HTTPS endpoints for your webhooks to ensure the data is encrypted in transit.\n\n### Invalid Signature Errors\n\nIf you're getting signature verification failures:\n\n1. **Check the raw payload**: Make sure you're using the raw request body, not a parsed JSON object\n2. **Verify the secret**: Ensure you're using the correct webhook secret from when the webhook was created\n3. **Check header parsing**: Make sure you're correctly extracting the timestamp and signatures from the header\n4. **Encoding issues**: Ensure consistent UTF-8 encoding throughout the verification process\n\n### Testing Signatures Locally\n\nYou can test your signature verification logic using the webhook secret and a sample payload:\n\n```python python theme={null}",
  "code_samples": [
    {
      "code": "Exa-Signature: t=1234567890,v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd",
      "language": "unknown"
    },
    {
      "code": "</Tab>\n\n  <Tab title=\"JavaScript/Node.js\">",
      "language": "unknown"
    },
    {
      "code": "</Tab>\n\n  <Tab title=\"Java\">",
      "language": "unknown"
    },
    {
      "code": "</Tab>\n</Tabs>\n\n***\n\n<br />\n\n## Security Best Practices\n\nFollowing these practices will help ensure your webhook implementation is secure and robust:\n\n* **Always Verify Signatures** - Never process webhook data without first verifying the signature. This prevents attackers from sending fake webhooks to your endpoint.\n\n* **Use Timing-Safe Comparison** - When comparing signatures, use functions like `hmac.compare_digest()` in Python or `crypto.timingSafeEqual()` in Node.js to prevent timing attacks.\n\n* **Check Timestamp Freshness** - Consider rejecting webhooks with timestamps that are too old (e.g., older than 5 minutes) to prevent replay attacks.\n\n* **Store Secrets Securely** - Store your webhook secrets in environment variables or a secure secret management system. Never hardcode them in your application. **Important**: The webhook secret is only returned when you [create a webhook](https://docs.exa.ai/websets/api/webhooks/create-a-webhook) - make sure to save it securely as it cannot be retrieved later.\n\n* **Use HTTPS** - Always use HTTPS endpoints for your webhooks to ensure the data is encrypted in transit.\n\n***\n\n<br />\n\n## Troubleshooting\n\n### Invalid Signature Errors\n\nIf you're getting signature verification failures:\n\n1. **Check the raw payload**: Make sure you're using the raw request body, not a parsed JSON object\n2. **Verify the secret**: Ensure you're using the correct webhook secret from when the webhook was created\n3. **Check header parsing**: Make sure you're correctly extracting the timestamp and signatures from the header\n4. **Encoding issues**: Ensure consistent UTF-8 encoding throughout the verification process\n\n### Testing Signatures Locally\n\nYou can test your signature verification logic using the webhook secret and a sample payload:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "How Webhook Signatures Work",
      "id": "how-webhook-signatures-work"
    },
    {
      "level": "h2",
      "text": "Verification Process",
      "id": "verification-process"
    },
    {
      "level": "h2",
      "text": "Security Best Practices",
      "id": "security-best-practices"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "Invalid Signature Errors",
      "id": "invalid-signature-errors"
    },
    {
      "level": "h3",
      "text": "Testing Signatures Locally",
      "id": "testing-signatures-locally"
    }
  ],
  "url": "llms-txt#verifying-signatures",
  "links": []
}